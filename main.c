/* CRes, a self-extractible executables generator
 * Copyright (C) 2014  Romain Porte
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include <stdio.h>
#include <stdlib.h>

#define BUFSIZE 2048
#define BYTES_PER_LINE 12
#define OUT_FILE "out.c"

void usage(void) {
    printf("usage: cres <file1> <file2> ...\n");
}

void write_header(FILE *out) {
    fprintf(
        out,
        "/*\n *  File generated by cres\n */\n\n"
        "#include <stdio.h>\n\n");
}

void write_file_content_list(FILE *out, int amount) {
    int i;

    fprintf(out, "unsigned char *files[] = {\n");

    for (i = 1; i <= amount; i++) {
        fprintf(out, "    f%d", i);
        if (i != amount) {
            fprintf(out, ", ");
        }
    }

    fprintf(out, "\n};\n\n");
}

void write_file_length_list(FILE *out, const int *lengths, int amount) {
    int i;

    fprintf(out, "int filelength[] = {\n");

    for (i = 1; i <= amount; i++) {
        fprintf(out, "%d", lengths[i]);
        if (i != amount) {
            fprintf(out, ", ");
        }
    }

    fprintf(out, "\n};\n\n");
}

void write_file_name_list(FILE *out, const char **names, int amount) {
    int i;

    fprintf(out, "char *filenames[] = {\n    ");
    for (i = 0; i < amount; i++) {
        fprintf(out, "\"%s\", ", names[i]);
    }
    fprintf(out, "\"\"\n};\n\n");
}

void write_main(FILE *out, int number_of_files) {
    fprintf(
        out,
        "#define NUMFILES %d\n\n"
        "int main(void) {\n"
        "    int i, j;\n"
        "    FILE *fd;\n"
        "    for (i = 0; i < NUMFILES; ++i) {\n"
        "        printf(\"Extracting %%s...\", filenames[i]);\n"
        "        fd = fopen(filenames[i], \"w\");\n"
        "        for (j = 0; j < filelength[i]; j++) {\n"
        "           fputc(files[i][j], fd);\n"
        "        }\n"
        "        fclose(fd);\n"
            "    printf(\"\\n\");\n"
        "    }\n"
        "}\n",
        number_of_files);
}

int main(int argc, const char **argv) {
    int i;
    size_t j;
    int lineret;
    size_t l;
    unsigned char buffer[BUFSIZE];
    int *filelength;
    FILE *f, *out;

    if (argc < 2) {
        usage();
        return 0; 
    }

    if (!(out = fopen(OUT_FILE, "w"))) {
        fprintf(stderr, "unable to open output file %s for writing\n", OUT_FILE);
        return 1;
    }

    if (!(filelength = malloc(argc * sizeof(int)))) {
        perror("malloc");
        return 3;
    }

    for (i = 1; i < argc; i++) {
        filelength[i] = 0;
    }

    write_header(out);

    for(i = 1; i < argc; ++i) {
        if(!(f = fopen(argv[i], "rb"))) {
            fprintf(stderr, "unable to open input file %s for reading\n", argv[i]);
            fclose(out);
            free(filelength);
            return 2;
        }

        fprintf(out, "\nunsigned char f%d[] = {\n    ", i);

        lineret = 0;
        while((l = fread(buffer, 1, BUFSIZE, f))) {
            filelength[i] += l;
            for(j = 0; j < l; ++j) {
                fprintf(out, "0x%.2x, ", buffer[j]);
                if(++lineret == BYTES_PER_LINE) {
                    fprintf(out, "\n    ");
                    lineret = 0;
                }
            }
        }
        fprintf(out, "};\n\n");
        fclose(f);
    }

    write_file_content_list(out, argc - 1);
    write_file_length_list(out, filelength, argc - 1);
    write_file_name_list(out, argv + 1, argc - 1);
    write_main(out, argc - 1);

    fclose(out);
    free(filelength);

    return 0;
}
